<div>{{Prompt}}</div>

<input type="text" class="typing-field" id="typing-input" placeholder="Type command..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">

<div class="bash-code" id="typing-feedback"></div>

<div id="correct-commands" style="display: none;">{{Command}}</div>

<script>
(function() {
    var typingField = document.getElementById('typing-input');
    var feedbackDiv = document.getElementById('typing-feedback');
    var correctCommandsDiv = document.getElementById('correct-commands');
    
    if (!typingField || !feedbackDiv || !correctCommandsDiv) return;
    
    var correctCommands = correctCommandsDiv.innerHTML.split('<br>').filter(function(cmd) {
        return cmd.trim().length > 0;
    });
    
    // Function to check if a command is an alias and get the display version
    function getDisplayCommand(cmd) {
        var isAlias = cmd.startsWith('&gt;');
        var displayCmd = isAlias ? cmd.substring(4).trim() : cmd;
        return {
            original: cmd,
            display: displayCmd,
            isAlias: isAlias
        };
    }
    
    // Get display versions of all commands for matching
    var displayCommands = correctCommands.map(getDisplayCommand);
    
    function highlightBashToken(token, isFirstWord, isAlias) {
        var type = 'text';
        
        if (token.match(/^#/)) type = 'comment';
        else if (token.match(/^["']/)) type = 'string';
        else if (token.match(/^\$\w/)) type = 'variable';
        else if (token.match(/^\$[@0#?!]/)) type = 'variable';
        else if (token.match(/^--/)) type = 'flag-long';
        else if (token.match(/^-\w/)) type = 'flag';
        else if (token.match(/^(&&|\|\||>>|>|<|&|\||;)/)) type = 'symbol';
        else if (isFirstWord && token.match(/^\w/)) type = isAlias ? 'alias' : 'cmd';
        
        return '<span class="' + type + '">' + token + '</span>';
    }
    
    function highlightBashText(text, isAlias) {
        var tokens = text.match(/(#.*|["'][^"']*["']|--?\w+|\$[@0#?!]|\$\w+|[|&;><]|\|\||&&|>>|[^ \t\n\r"'$&|;()<>`]+|[ \t\n\r]+)/g) || [];
        var isFirstWord = true;
        var result = '';
        
        tokens.forEach(function(token) {
            if (token.match(/^[ \t\n\r]+/)) {
                result += token;
            } else {
                result += highlightBashToken(token, isFirstWord, isAlias);
                if (isFirstWord && token.match(/^\w/)) isFirstWord = false;
            }
        });
        
        return result;
    }
    
    function getBestMatch(userInput) {
        var bestMatch = null;
        var bestMatchLength = 0;
        
        for (var i = 0; i < displayCommands.length; i++) {
            var cmdInfo = displayCommands[i];
            var cmd = cmdInfo.display;
            var matchLength = 0;
            
            while (matchLength < userInput.length && matchLength < cmd.length && 
                   userInput[matchLength] === cmd[matchLength]) {
                matchLength++;
            }
            
            if (matchLength > bestMatchLength) {
                bestMatchLength = matchLength;
                bestMatch = cmdInfo;
            }
        }
        
        return {
            commandInfo: bestMatch,
            matchLength: bestMatchLength
        };
    }
    
    function updateFeedback() {
        var userInput = typingField.value;
        var bestMatch = getBestMatch(userInput);
        var feedbackHTML = '';
        
        if (bestMatch.matchLength > 0 && bestMatch.commandInfo) {
            feedbackHTML = highlightBashText(userInput.substring(0, bestMatch.matchLength), bestMatch.commandInfo.isAlias);
        }
        
        if (bestMatch.matchLength < userInput.length) {
            var incorrectPart = userInput.substring(bestMatch.matchLength);
            for (var i = 0; i < incorrectPart.length; i++) {
                feedbackHTML += '<span class="incorrect-char">' + incorrectPart[i] + '</span>';
            }
        }
        
        feedbackDiv.innerHTML = feedbackHTML;
        
        // Check if user input matches any display command exactly
        var isCorrect = false;
        for (var i = 0; i < displayCommands.length; i++) {
            if (userInput === displayCommands[i].display) {
                isCorrect = true;
                break;
            }
        }
        
        if (isCorrect) {
            typingField.classList.add('correct');
        } else {
            typingField.classList.remove('correct');
        }
    }
    
    typingField.addEventListener('input', updateFeedback);
    
    typingField.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            var bestMatch = getBestMatch(typingField.value);
            if (bestMatch.commandInfo) {
                // Only autocomplete with the display version (without >)
                typingField.value = bestMatch.commandInfo.display;
                updateFeedback();
            }
        }
    });
    
    typingField.focus();
    updateFeedback();
})();
</script>
